/* tslint:disable */
/* eslint-disable */
/**
 * RepRapFirmware
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.4.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface RrConnectGet200Response
 */
export interface RrConnectGet200Response {
    /**
     * Error code (0 = success, 1 = invalid password, 2 = no more sessions available)
     * @type {number}
     * @memberof RrConnectGet200Response
     */
    'err'?: number;
    /**
     * 
     * @type {number}
     * @memberof RrConnectGet200Response
     */
    'sessionTimeout'?: number;
    /**
     * 
     * @type {string}
     * @memberof RrConnectGet200Response
     */
    'boardType'?: string;
}
/**
 * 
 * @export
 * @interface RrDeleteGet200Response
 */
export interface RrDeleteGet200Response {
    /**
     * File delete result (either `0` on success or `1` on error)
     * @type {number}
     * @memberof RrDeleteGet200Response
     */
    'err'?: number;
}
/**
 * 
 * @export
 * @interface RrDisconnectGet200Response
 */
export interface RrDisconnectGet200Response {
    /**
     * Error code (0 = success, 1 = failed to remove session)
     * @type {any}
     * @memberof RrDisconnectGet200Response
     */
    'err'?: any;
}
/**
 * 
 * @export
 * @interface RrFileinfoGet200Response
 */
export interface RrFileinfoGet200Response {
    /**
     * Error code, either `0` on success or `1` on error
     * @type {number}
     * @memberof RrFileinfoGet200Response
     */
    'err'?: number;
    /**
     * Filename of the G-code file
     * @type {string}
     * @memberof RrFileinfoGet200Response
     */
    'fileName'?: string;
    /**
     * Size of the file
     * @type {number}
     * @memberof RrFileinfoGet200Response
     */
    'size'?: number;
    /**
     * Datetime when the file was last modified
     * @type {string}
     * @memberof RrFileinfoGet200Response
     */
    'lastModified'?: string;
    /**
     * Object height (in mm)
     * @type {number}
     * @memberof RrFileinfoGet200Response
     */
    'height'?: number;
    /**
     * Layer height (in mm)
     * @type {number}
     * @memberof RrFileinfoGet200Response
     */
    'layerHeight'?: number;
    /**
     * Number of layers
     * @type {number}
     * @memberof RrFileinfoGet200Response
     */
    'numLayers'?: number;
    /**
     * Expected time to print (in s)
     * @type {number}
     * @memberof RrFileinfoGet200Response
     */
    'printTime'?: number;
    /**
     * Simulated time to print (in s)
     * @type {number}
     * @memberof RrFileinfoGet200Response
     */
    'simulatedTime'?: number;
    /**
     * Filament usage (in mm)
     * @type {Array<number>}
     * @memberof RrFileinfoGet200Response
     */
    'filament'?: Array<number>;
    /**
     * Current print duration (in s)
     * @type {number}
     * @memberof RrFileinfoGet200Response
     */
    'printDuration'?: number;
    /**
     * Info about embedded thumbnails
     * @type {Array<RrFileinfoGet200ResponseThumbnailsInner>}
     * @memberof RrFileinfoGet200Response
     */
    'thumbnails'?: Array<RrFileinfoGet200ResponseThumbnailsInner>;
    /**
     * Application that generated the file
     * @type {string}
     * @memberof RrFileinfoGet200Response
     */
    'generatedBy'?: string;
}
/**
 * 
 * @export
 * @interface RrFileinfoGet200ResponseThumbnailsInner
 */
export interface RrFileinfoGet200ResponseThumbnailsInner {
    /**
     * Width of the thumbnail (in px)
     * @type {number}
     * @memberof RrFileinfoGet200ResponseThumbnailsInner
     */
    'width'?: number;
    /**
     * Height of the thumbnail (in px)
     * @type {number}
     * @memberof RrFileinfoGet200ResponseThumbnailsInner
     */
    'height'?: number;
    /**
     * Thumbnail format
     * @type {string}
     * @memberof RrFileinfoGet200ResponseThumbnailsInner
     */
    'format'?: RrFileinfoGet200ResponseThumbnailsInnerFormatEnum;
    /**
     * File offset (to be used with rr_thumbnail)
     * @type {number}
     * @memberof RrFileinfoGet200ResponseThumbnailsInner
     */
    'offset'?: number;
    /**
     * Size of the thumbnail
     * @type {number}
     * @memberof RrFileinfoGet200ResponseThumbnailsInner
     */
    'size'?: number;
}

export const RrFileinfoGet200ResponseThumbnailsInnerFormatEnum = {
    Png: 'png',
    Qoi: 'qoi',
    Jpeg: 'jpeg'
} as const;

export type RrFileinfoGet200ResponseThumbnailsInnerFormatEnum = typeof RrFileinfoGet200ResponseThumbnailsInnerFormatEnum[keyof typeof RrFileinfoGet200ResponseThumbnailsInnerFormatEnum];

/**
 * 
 * @export
 * @interface RrFilelistGet200Response
 */
export interface RrFilelistGet200Response {
    /**
     * Queried directory
     * @type {string}
     * @memberof RrFilelistGet200Response
     */
    'dir'?: string;
    /**
     * First item index returned
     * @type {number}
     * @memberof RrFilelistGet200Response
     */
    'first'?: number;
    /**
     * 
     * @type {Array<RrFilelistGet200ResponseFilesInner>}
     * @memberof RrFilelistGet200Response
     */
    'files'?: Array<RrFilelistGet200ResponseFilesInner>;
    /**
     * Index of the next item to query or 0 if there are no more items
     * @type {number}
     * @memberof RrFilelistGet200Response
     */
    'next'?: number;
    /**
     * Error code  - `0`: List query successful - `1`: Drive is not mounted - `2`: Directory does not exist 
     * @type {number}
     * @memberof RrFilelistGet200Response
     */
    'err'?: number;
}
/**
 * Files or directories
 * @export
 * @interface RrFilelistGet200ResponseFilesInner
 */
export interface RrFilelistGet200ResponseFilesInner {
    /**
     * Type of this item (d = directory, f = file)
     * @type {string}
     * @memberof RrFilelistGet200ResponseFilesInner
     */
    'type'?: RrFilelistGet200ResponseFilesInnerTypeEnum;
    /**
     * Filename of this item
     * @type {string}
     * @memberof RrFilelistGet200ResponseFilesInner
     */
    'name'?: string;
    /**
     * Size of this item in bytes
     * @type {number}
     * @memberof RrFilelistGet200ResponseFilesInner
     */
    'size'?: number;
    /**
     * Last modified datetime of this item
     * @type {string}
     * @memberof RrFilelistGet200ResponseFilesInner
     */
    'date'?: string;
}

export const RrFilelistGet200ResponseFilesInnerTypeEnum = {
    D: 'd',
    F: 'f'
} as const;

export type RrFilelistGet200ResponseFilesInnerTypeEnum = typeof RrFilelistGet200ResponseFilesInnerTypeEnum[keyof typeof RrFilelistGet200ResponseFilesInnerTypeEnum];

/**
 * 
 * @export
 * @interface RrFilesGet200Response
 */
export interface RrFilesGet200Response {
    /**
     * Queried directory
     * @type {string}
     * @memberof RrFilesGet200Response
     */
    'dir'?: string;
    /**
     * First item index returned
     * @type {number}
     * @memberof RrFilesGet200Response
     */
    'first'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof RrFilesGet200Response
     */
    'files'?: Array<string>;
    /**
     * Index of the next item to query or 0 if there are no more items
     * @type {number}
     * @memberof RrFilesGet200Response
     */
    'next'?: number;
    /**
     * Error code  - `0`: List query successful - `1`: Drive is not mounted - `2`: Directory does not exist 
     * @type {number}
     * @memberof RrFilesGet200Response
     */
    'err'?: number;
}
/**
 * 
 * @export
 * @interface RrGcodeGet200Response
 */
export interface RrGcodeGet200Response {
    /**
     * How much buffer space for new G/M/T-codes is still available
     * @type {number}
     * @memberof RrGcodeGet200Response
     */
    'bufferSpace'?: number;
}
/**
 * 
 * @export
 * @interface RrMkdirGet200Response
 */
export interface RrMkdirGet200Response {
    /**
     * Directory create result (either `0` on success or `1` on error)
     * @type {number}
     * @memberof RrMkdirGet200Response
     */
    'err'?: number;
}
/**
 * 
 * @export
 * @interface RrModelGet200Response
 */
export interface RrModelGet200Response {
    /**
     * Queried key
     * @type {string}
     * @memberof RrModelGet200Response
     */
    'key'?: string;
    /**
     * Query flags
     * @type {string}
     * @memberof RrModelGet200Response
     */
    'flags'?: string;
    /**
     * 
     * @type {object}
     * @memberof RrModelGet200Response
     */
    'result'?: object;
}
/**
 * 
 * @export
 * @interface RrMoveGet200Response
 */
export interface RrMoveGet200Response {
    /**
     * File move result (either `0` on success or `1` on error)
     * @type {number}
     * @memberof RrMoveGet200Response
     */
    'err'?: number;
}
/**
 * 
 * @export
 * @interface RrThumbnailGet200Response
 */
export interface RrThumbnailGet200Response {
    /**
     * Filename of the G-code file
     * @type {string}
     * @memberof RrThumbnailGet200Response
     */
    'fileName'?: string;
    /**
     * Offset of the thumbnail
     * @type {number}
     * @memberof RrThumbnailGet200Response
     */
    'offset'?: number;
    /**
     * Base64-encoded thumbnail data
     * @type {string}
     * @memberof RrThumbnailGet200Response
     */
    'data'?: string;
    /**
     * Next thumbnail offset or 0 if complete
     * @type {number}
     * @memberof RrThumbnailGet200Response
     */
    'next'?: number;
    /**
     * Error code, either `0` on success or `1` on error
     * @type {number}
     * @memberof RrThumbnailGet200Response
     */
    'err'?: number;
}
/**
 * 
 * @export
 * @interface RrUploadGet200Response
 */
export interface RrUploadGet200Response {
    /**
     * Last file upload result (can be either `0` if the last upload successfully finished or `1` if an error occurred)
     * @type {number}
     * @memberof RrUploadGet200Response
     */
    'err'?: number;
}
/**
 * 
 * @export
 * @interface RrUploadPost200Response
 */
export interface RrUploadPost200Response {
    /**
     * File upload result (can be either `0` if the last upload uccessfully finished or `1` if an error occurred [e.g. CRC mismatch])
     * @type {number}
     * @memberof RrUploadPost200Response
     */
    'err'?: number;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the configuration response. This request provides a JSON object with values that are expected to change rarely. Deprecated in RRF 3.0 and later, use rr_model instead 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        rrConfigGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rr_config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Attempt to create a new connection and log in using the (optional) password 
         * @param {string} [password] Password
         * @param {string} [time] Current datetime that will be used to update RepRapFirmware\&#39;s internal clock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrConnectGet: async (password?: string, time?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rr_connect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = (time as any instanceof Date) ?
                    (time as any).toISOString() :
                    time;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a file or directory 
         * @param {string} name Name of the file to delete
         * @param {RrDeleteGetRecursiveEnum} [recursive] Delete directory recursively (if applicable)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrDeleteGet: async (name: string, recursive?: RrDeleteGetRecursiveEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('rrDeleteGet', 'name', name)
            const localVarPath = `/rr_delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disconnect again from the RepRapFirmware controller 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrDisconnectGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rr_disconnect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a file 
         * @param {string} name Path to the file to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrDownloadGet: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('rrDownloadGet', 'name', name)
            const localVarPath = `/rr_download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Parse a G-code job file and return retrieved information. If no file is specified, information about the file being printed is returned 
         * @param {string} [name] Path to the file to parse
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrFileinfoGet: async (name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rr_fileinfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a (partial) file list 
         * @param {string} dir Directory to query
         * @param {number} [first] First item index to return (defaults to &#x60;0&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrFilelistGet: async (dir: string, first?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dir' is not null or undefined
            assertParamExists('rrFilelistGet', 'dir', dir)
            const localVarPath = `/rr_filelist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dir !== undefined) {
                localVarQueryParameter['dir'] = dir;
            }

            if (first !== undefined) {
                localVarQueryParameter['first'] = first;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of files without any attributes 
         * @param {string} dir Directory to query
         * @param {number} [first] First item index to return (defaults to &#x60;0&#x60;)
         * @param {number} [flagDirs] Prefix directories with a &#x60;*&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrFilesGet: async (dir: string, first?: number, flagDirs?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dir' is not null or undefined
            assertParamExists('rrFilesGet', 'dir', dir)
            const localVarPath = `/rr_files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dir !== undefined) {
                localVarQueryParameter['dir'] = dir;
            }

            if (first !== undefined) {
                localVarQueryParameter['first'] = first;
            }

            if (flagDirs !== undefined) {
                localVarQueryParameter['flagDirs'] = flagDirs;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Execute arbitrary G/M/T-code(s) 
         * @param {string} gcode G/M/T-code to execute. This parameter must be present although it can be empty
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrGcodeGet: async (gcode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gcode' is not null or undefined
            assertParamExists('rrGcodeGet', 'gcode', gcode)
            const localVarPath = `/rr_gcode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (gcode !== undefined) {
                localVarQueryParameter['gcode'] = gcode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new directory 
         * @param {string} dir Directory to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrMkdirGet: async (dir: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dir' is not null or undefined
            assertParamExists('rrMkdirGet', 'dir', dir)
            const localVarPath = `/rr_mkdir`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dir !== undefined) {
                localVarQueryParameter['dir'] = dir;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve object model information like [M409](https://duet3d.dozuki.com/Wiki/Gcode#Section_M409_Query_object_model). Supported in RRF 3. and later 
         * @param {string} key Key to query
         * @param {string} flags Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrModelGet: async (key: string, flags: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('rrModelGet', 'key', key)
            // verify required parameter 'flags' is not null or undefined
            assertParamExists('rrModelGet', 'flags', flags)
            const localVarPath = `/rr_model`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (flags !== undefined) {
                localVarQueryParameter['flags'] = flags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move a file or directory 
         * @param {string} old Current path to the file or directory
         * @param {string} _new New path of the file or directory
         * @param {RrMoveGetDeleteexistingEnum} [deleteexisting] Set this to &#x60;yes&#x60; to delete the new file if it already exists. Defaults to &#x60;no&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrMoveGet: async (old: string, _new: string, deleteexisting?: RrMoveGetDeleteexistingEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'old' is not null or undefined
            assertParamExists('rrMoveGet', 'old', old)
            // verify required parameter '_new' is not null or undefined
            assertParamExists('rrMoveGet', '_new', _new)
            const localVarPath = `/rr_move`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (old !== undefined) {
                localVarQueryParameter['old'] = old;
            }

            if (_new !== undefined) {
                localVarQueryParameter['new'] = _new;
            }

            if (deleteexisting !== undefined) {
                localVarQueryParameter['deleteexisting'] = deleteexisting;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the last G-code reply.  The G-code reply is buffered per connected HTTP client and it is discarded when every HTTP client has fetched it or when the firmware is short on memory and the client has not requested it within reasonable time (1 second) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrReplyGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rr_reply`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a status response from RepRapFirmware in JSON format. Deprecated in RRF 3.0 and later, use `rr_model` instead 
         * @param {number} [type] Type of the status response (defaults to 1)  - 1: Standard status response - 2: Advanced status response. This also contains fields from the standard status response - 3: Print status response. This contains fields from the standard status response as well as information about the current (print) job 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        rrStatusGet: async (type?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rr_status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query a thumbnail from a G-code file 
         * @param {string} name Filename to query
         * @param {number} offset File offset of the thumbnail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrThumbnailGet: async (name: string, offset: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('rrThumbnailGet', 'name', name)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('rrThumbnailGet', 'offset', offset)
            const localVarPath = `/rr_thumbnail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the last file upload result 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrUploadGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rr_upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a file 
         * @param {string} name Path to the file to upload
         * @param {string} [time] ISO8601-like represenation of the time the file was last modified
         * @param {string} [crc32] CRC32 checksum of the file content as hex string *without* leading &#x60;0x&#x60;. Usage of this parameter is encouraged
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrUploadPost: async (name: string, time?: string, crc32?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('rrUploadPost', 'name', name)
            const localVarPath = `/rr_upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = (time as any instanceof Date) ?
                    (time as any).toISOString() :
                    time;
            }

            if (crc32 !== undefined) {
                localVarQueryParameter['crc32'] = crc32;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve the configuration response. This request provides a JSON object with values that are expected to change rarely. Deprecated in RRF 3.0 and later, use rr_model instead 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async rrConfigGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrConfigGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.rrConfigGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Attempt to create a new connection and log in using the (optional) password 
         * @param {string} [password] Password
         * @param {string} [time] Current datetime that will be used to update RepRapFirmware\&#39;s internal clock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrConnectGet(password?: string, time?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RrConnectGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrConnectGet(password, time, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.rrConnectGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a file or directory 
         * @param {string} name Name of the file to delete
         * @param {RrDeleteGetRecursiveEnum} [recursive] Delete directory recursively (if applicable)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrDeleteGet(name: string, recursive?: RrDeleteGetRecursiveEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RrDeleteGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrDeleteGet(name, recursive, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.rrDeleteGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Disconnect again from the RepRapFirmware controller 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrDisconnectGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RrDisconnectGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrDisconnectGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.rrDisconnectGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Download a file 
         * @param {string} name Path to the file to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrDownloadGet(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrDownloadGet(name, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.rrDownloadGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Parse a G-code job file and return retrieved information. If no file is specified, information about the file being printed is returned 
         * @param {string} [name] Path to the file to parse
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrFileinfoGet(name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RrFileinfoGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrFileinfoGet(name, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.rrFileinfoGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a (partial) file list 
         * @param {string} dir Directory to query
         * @param {number} [first] First item index to return (defaults to &#x60;0&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrFilelistGet(dir: string, first?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RrFilelistGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrFilelistGet(dir, first, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.rrFilelistGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a list of files without any attributes 
         * @param {string} dir Directory to query
         * @param {number} [first] First item index to return (defaults to &#x60;0&#x60;)
         * @param {number} [flagDirs] Prefix directories with a &#x60;*&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrFilesGet(dir: string, first?: number, flagDirs?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RrFilesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrFilesGet(dir, first, flagDirs, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.rrFilesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Execute arbitrary G/M/T-code(s) 
         * @param {string} gcode G/M/T-code to execute. This parameter must be present although it can be empty
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrGcodeGet(gcode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RrGcodeGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrGcodeGet(gcode, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.rrGcodeGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new directory 
         * @param {string} dir Directory to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrMkdirGet(dir: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RrMkdirGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrMkdirGet(dir, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.rrMkdirGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve object model information like [M409](https://duet3d.dozuki.com/Wiki/Gcode#Section_M409_Query_object_model). Supported in RRF 3. and later 
         * @param {string} key Key to query
         * @param {string} flags Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrModelGet(key: string, flags: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RrModelGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrModelGet(key, flags, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.rrModelGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Move a file or directory 
         * @param {string} old Current path to the file or directory
         * @param {string} _new New path of the file or directory
         * @param {RrMoveGetDeleteexistingEnum} [deleteexisting] Set this to &#x60;yes&#x60; to delete the new file if it already exists. Defaults to &#x60;no&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrMoveGet(old: string, _new: string, deleteexisting?: RrMoveGetDeleteexistingEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RrMoveGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrMoveGet(old, _new, deleteexisting, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.rrMoveGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the last G-code reply.  The G-code reply is buffered per connected HTTP client and it is discarded when every HTTP client has fetched it or when the firmware is short on memory and the client has not requested it within reasonable time (1 second) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrReplyGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrReplyGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.rrReplyGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a status response from RepRapFirmware in JSON format. Deprecated in RRF 3.0 and later, use `rr_model` instead 
         * @param {number} [type] Type of the status response (defaults to 1)  - 1: Standard status response - 2: Advanced status response. This also contains fields from the standard status response - 3: Print status response. This contains fields from the standard status response as well as information about the current (print) job 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async rrStatusGet(type?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrStatusGet(type, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.rrStatusGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Query a thumbnail from a G-code file 
         * @param {string} name Filename to query
         * @param {number} offset File offset of the thumbnail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrThumbnailGet(name: string, offset: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RrThumbnailGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrThumbnailGet(name, offset, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.rrThumbnailGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get the last file upload result 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrUploadGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RrUploadGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrUploadGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.rrUploadGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Upload a file 
         * @param {string} name Path to the file to upload
         * @param {string} [time] ISO8601-like represenation of the time the file was last modified
         * @param {string} [crc32] CRC32 checksum of the file content as hex string *without* leading &#x60;0x&#x60;. Usage of this parameter is encouraged
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rrUploadPost(name: string, time?: string, crc32?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RrUploadPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rrUploadPost(name, time, crc32, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.rrUploadPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve the configuration response. This request provides a JSON object with values that are expected to change rarely. Deprecated in RRF 3.0 and later, use rr_model instead 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        rrConfigGet(options?: any): AxiosPromise<void> {
            return localVarFp.rrConfigGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Attempt to create a new connection and log in using the (optional) password 
         * @param {string} [password] Password
         * @param {string} [time] Current datetime that will be used to update RepRapFirmware\&#39;s internal clock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrConnectGet(password?: string, time?: string, options?: any): AxiosPromise<RrConnectGet200Response> {
            return localVarFp.rrConnectGet(password, time, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a file or directory 
         * @param {string} name Name of the file to delete
         * @param {RrDeleteGetRecursiveEnum} [recursive] Delete directory recursively (if applicable)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrDeleteGet(name: string, recursive?: RrDeleteGetRecursiveEnum, options?: any): AxiosPromise<RrDeleteGet200Response> {
            return localVarFp.rrDeleteGet(name, recursive, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Disconnect again from the RepRapFirmware controller 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrDisconnectGet(options?: any): AxiosPromise<RrDisconnectGet200Response> {
            return localVarFp.rrDisconnectGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a file 
         * @param {string} name Path to the file to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrDownloadGet(name: string, options?: any): AxiosPromise<void> {
            return localVarFp.rrDownloadGet(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Parse a G-code job file and return retrieved information. If no file is specified, information about the file being printed is returned 
         * @param {string} [name] Path to the file to parse
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrFileinfoGet(name?: string, options?: any): AxiosPromise<RrFileinfoGet200Response> {
            return localVarFp.rrFileinfoGet(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a (partial) file list 
         * @param {string} dir Directory to query
         * @param {number} [first] First item index to return (defaults to &#x60;0&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrFilelistGet(dir: string, first?: number, options?: any): AxiosPromise<RrFilelistGet200Response> {
            return localVarFp.rrFilelistGet(dir, first, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of files without any attributes 
         * @param {string} dir Directory to query
         * @param {number} [first] First item index to return (defaults to &#x60;0&#x60;)
         * @param {number} [flagDirs] Prefix directories with a &#x60;*&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrFilesGet(dir: string, first?: number, flagDirs?: number, options?: any): AxiosPromise<RrFilesGet200Response> {
            return localVarFp.rrFilesGet(dir, first, flagDirs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Execute arbitrary G/M/T-code(s) 
         * @param {string} gcode G/M/T-code to execute. This parameter must be present although it can be empty
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrGcodeGet(gcode: string, options?: any): AxiosPromise<RrGcodeGet200Response> {
            return localVarFp.rrGcodeGet(gcode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new directory 
         * @param {string} dir Directory to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrMkdirGet(dir: string, options?: any): AxiosPromise<RrMkdirGet200Response> {
            return localVarFp.rrMkdirGet(dir, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve object model information like [M409](https://duet3d.dozuki.com/Wiki/Gcode#Section_M409_Query_object_model). Supported in RRF 3. and later 
         * @param {string} key Key to query
         * @param {string} flags Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrModelGet(key: string, flags: string, options?: any): AxiosPromise<RrModelGet200Response> {
            return localVarFp.rrModelGet(key, flags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move a file or directory 
         * @param {string} old Current path to the file or directory
         * @param {string} _new New path of the file or directory
         * @param {RrMoveGetDeleteexistingEnum} [deleteexisting] Set this to &#x60;yes&#x60; to delete the new file if it already exists. Defaults to &#x60;no&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrMoveGet(old: string, _new: string, deleteexisting?: RrMoveGetDeleteexistingEnum, options?: any): AxiosPromise<RrMoveGet200Response> {
            return localVarFp.rrMoveGet(old, _new, deleteexisting, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the last G-code reply.  The G-code reply is buffered per connected HTTP client and it is discarded when every HTTP client has fetched it or when the firmware is short on memory and the client has not requested it within reasonable time (1 second) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrReplyGet(options?: any): AxiosPromise<void> {
            return localVarFp.rrReplyGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a status response from RepRapFirmware in JSON format. Deprecated in RRF 3.0 and later, use `rr_model` instead 
         * @param {number} [type] Type of the status response (defaults to 1)  - 1: Standard status response - 2: Advanced status response. This also contains fields from the standard status response - 3: Print status response. This contains fields from the standard status response as well as information about the current (print) job 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        rrStatusGet(type?: number, options?: any): AxiosPromise<void> {
            return localVarFp.rrStatusGet(type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query a thumbnail from a G-code file 
         * @param {string} name Filename to query
         * @param {number} offset File offset of the thumbnail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrThumbnailGet(name: string, offset: number, options?: any): AxiosPromise<RrThumbnailGet200Response> {
            return localVarFp.rrThumbnailGet(name, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the last file upload result 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrUploadGet(options?: any): AxiosPromise<RrUploadGet200Response> {
            return localVarFp.rrUploadGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a file 
         * @param {string} name Path to the file to upload
         * @param {string} [time] ISO8601-like represenation of the time the file was last modified
         * @param {string} [crc32] CRC32 checksum of the file content as hex string *without* leading &#x60;0x&#x60;. Usage of this parameter is encouraged
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rrUploadPost(name: string, time?: string, crc32?: string, options?: any): AxiosPromise<RrUploadPost200Response> {
            return localVarFp.rrUploadPost(name, time, crc32, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve the configuration response. This request provides a JSON object with values that are expected to change rarely. Deprecated in RRF 3.0 and later, use rr_model instead 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rrConfigGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rrConfigGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Attempt to create a new connection and log in using the (optional) password 
     * @param {string} [password] Password
     * @param {string} [time] Current datetime that will be used to update RepRapFirmware\&#39;s internal clock
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rrConnectGet(password?: string, time?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rrConnectGet(password, time, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a file or directory 
     * @param {string} name Name of the file to delete
     * @param {RrDeleteGetRecursiveEnum} [recursive] Delete directory recursively (if applicable)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rrDeleteGet(name: string, recursive?: RrDeleteGetRecursiveEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rrDeleteGet(name, recursive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Disconnect again from the RepRapFirmware controller 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rrDisconnectGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rrDisconnectGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a file 
     * @param {string} name Path to the file to download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rrDownloadGet(name: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rrDownloadGet(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Parse a G-code job file and return retrieved information. If no file is specified, information about the file being printed is returned 
     * @param {string} [name] Path to the file to parse
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rrFileinfoGet(name?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rrFileinfoGet(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a (partial) file list 
     * @param {string} dir Directory to query
     * @param {number} [first] First item index to return (defaults to &#x60;0&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rrFilelistGet(dir: string, first?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rrFilelistGet(dir, first, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of files without any attributes 
     * @param {string} dir Directory to query
     * @param {number} [first] First item index to return (defaults to &#x60;0&#x60;)
     * @param {number} [flagDirs] Prefix directories with a &#x60;*&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rrFilesGet(dir: string, first?: number, flagDirs?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rrFilesGet(dir, first, flagDirs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Execute arbitrary G/M/T-code(s) 
     * @param {string} gcode G/M/T-code to execute. This parameter must be present although it can be empty
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rrGcodeGet(gcode: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rrGcodeGet(gcode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new directory 
     * @param {string} dir Directory to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rrMkdirGet(dir: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rrMkdirGet(dir, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve object model information like [M409](https://duet3d.dozuki.com/Wiki/Gcode#Section_M409_Query_object_model). Supported in RRF 3. and later 
     * @param {string} key Key to query
     * @param {string} flags Query flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rrModelGet(key: string, flags: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rrModelGet(key, flags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move a file or directory 
     * @param {string} old Current path to the file or directory
     * @param {string} _new New path of the file or directory
     * @param {RrMoveGetDeleteexistingEnum} [deleteexisting] Set this to &#x60;yes&#x60; to delete the new file if it already exists. Defaults to &#x60;no&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rrMoveGet(old: string, _new: string, deleteexisting?: RrMoveGetDeleteexistingEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rrMoveGet(old, _new, deleteexisting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the last G-code reply.  The G-code reply is buffered per connected HTTP client and it is discarded when every HTTP client has fetched it or when the firmware is short on memory and the client has not requested it within reasonable time (1 second) 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rrReplyGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rrReplyGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a status response from RepRapFirmware in JSON format. Deprecated in RRF 3.0 and later, use `rr_model` instead 
     * @param {number} [type] Type of the status response (defaults to 1)  - 1: Standard status response - 2: Advanced status response. This also contains fields from the standard status response - 3: Print status response. This contains fields from the standard status response as well as information about the current (print) job 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rrStatusGet(type?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rrStatusGet(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query a thumbnail from a G-code file 
     * @param {string} name Filename to query
     * @param {number} offset File offset of the thumbnail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rrThumbnailGet(name: string, offset: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rrThumbnailGet(name, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the last file upload result 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rrUploadGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rrUploadGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a file 
     * @param {string} name Path to the file to upload
     * @param {string} [time] ISO8601-like represenation of the time the file was last modified
     * @param {string} [crc32] CRC32 checksum of the file content as hex string *without* leading &#x60;0x&#x60;. Usage of this parameter is encouraged
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rrUploadPost(name: string, time?: string, crc32?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rrUploadPost(name, time, crc32, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RrDeleteGetRecursiveEnum = {
    Yes: 'yes',
    No: 'no'
} as const;
export type RrDeleteGetRecursiveEnum = typeof RrDeleteGetRecursiveEnum[keyof typeof RrDeleteGetRecursiveEnum];
/**
 * @export
 */
export const RrMoveGetDeleteexistingEnum = {
    Yes: 'yes',
    No: 'no'
} as const;
export type RrMoveGetDeleteexistingEnum = typeof RrMoveGetDeleteexistingEnum[keyof typeof RrMoveGetDeleteexistingEnum];


